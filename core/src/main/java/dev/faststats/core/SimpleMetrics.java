package dev.faststats.core;

import com.google.gson.JsonObject;
import dev.faststats.core.chart.Chart;
import org.jetbrains.annotations.Async;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.MustBeInvokedByOverriders;
import org.jetbrains.annotations.VisibleForTesting;
import org.jspecify.annotations.Nullable;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.net.ConnectException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpConnectTimeoutException;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Duration;
import java.util.HashSet;
import java.util.Optional;
import java.util.Properties;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.BiPredicate;
import java.util.zip.GZIPOutputStream;

import static java.nio.charset.StandardCharsets.UTF_8;

public abstract class SimpleMetrics implements Metrics {
    private final HttpClient httpClient = HttpClient.newBuilder()
            .connectTimeout(Duration.ofSeconds(3))
            .version(HttpClient.Version.HTTP_1_1)
            .build();
    private @Nullable ScheduledExecutorService executor = null;

    private final Set<Chart<?>> charts;
    private final Config config;
    private final @Token String token;
    private final @Nullable ErrorTracker tracker;
    private final URI url;
    private final boolean debug;

    @Contract(mutates = "io")
    @SuppressWarnings("PatternValidation")
    protected SimpleMetrics(final Factory<?, ?> factory, final Config config) throws IllegalStateException {
        if (factory.token == null) throw new IllegalStateException("Token must be specified");

        this.config = config;
        this.charts = config.additionalMetrics ? Set.copyOf(factory.charts) : Set.of();
        this.debug = factory.debug || Boolean.getBoolean("faststats.debug") || config.debug();
        this.token = factory.token;
        this.tracker = config.errorTracking ? factory.tracker : null;
        this.url = factory.url;
    }

    @Contract(mutates = "io")
    protected SimpleMetrics(final Factory<?, ?> factory, final Path config) throws IllegalStateException {
        this(factory, Config.read(config));
    }

    @VisibleForTesting
    protected SimpleMetrics(final Config config, final Set<Chart<?>> charts, @Token final String token, @Nullable final ErrorTracker tracker, final URI url, final boolean debug) {
        if (!token.matches(Token.PATTERN)) {
            throw new IllegalArgumentException("Invalid token '" + token + "', must match '" + Token.PATTERN + "'");
        }

        this.charts = config.additionalMetrics ? Set.copyOf(charts) : Set.of();
        this.config = config;
        this.debug = debug;
        this.token = token;
        this.tracker = tracker;
        this.url = url;
    }

    protected String getOnboardingMessage() {
        return """
                This plugin uses FastStats to collect anonymous usage statistics.
                No personal or identifying information is ever collected.
                To opt out, set 'enabled=false' in the metrics configuration file.
                Learn more at: https://faststats.dev/info
                
                Since this is your first start with FastStats, metrics submission will not start
                until you restart the server to allow you to opt out if you prefer.""";
    }

    protected long getInitialDelay() {
        return TimeUnit.SECONDS.toMillis(Long.getLong("faststats.initial-delay", 30));
    }

    protected long getPeriod() {
        return TimeUnit.MINUTES.toMillis(30);
    }

    @Async.Schedule
    @MustBeInvokedByOverriders
    protected void startSubmitting() {
        startSubmitting(getInitialDelay(), getPeriod(), TimeUnit.MILLISECONDS);
    }

    private void startSubmitting(final long initialDelay, final long period, final TimeUnit unit) {
        if (Boolean.getBoolean("faststats.first-run")) {
            info("Skipping metrics submission due to first-run flag");
            return;
        }

        if (config.firstRun) {

            var separatorLength = 0;
            final var split = getOnboardingMessage().split("\n");
            for (final var s : split) if (s.length() > separatorLength) separatorLength = s.length();

            printInfo("-".repeat(separatorLength));
            for (final var s : split) printInfo(s);
            printInfo("-".repeat(separatorLength));

            System.setProperty("faststats.first-run", "true");
            if (!config.externallyManaged()) return;
        }

        final var enabled = Boolean.parseBoolean(System.getProperty("faststats.enabled", "true"));

        if (!config.enabled() || !enabled) {
            warn("Metrics disabled, not starting submission");
            return;
        }

        if (isSubmitting()) {
            warn("Metrics already submitting, not starting again");
            return;
        }

        this.executor = Executors.newSingleThreadScheduledExecutor(runnable -> {
            final var thread = new Thread(runnable, "metrics-submitter");
            thread.setDaemon(true);
            return thread;
        });

        info("Starting metrics submission");
        executor.scheduleAtFixedRate(() -> {
            try {
                submit();
            } catch (final Throwable t) {
                error("Failed to submit metrics", t);
            }
        }, Math.max(0, initialDelay), Math.max(1000, period), unit);
    }

    protected boolean isSubmitting() {
        return executor != null && !executor.isShutdown();
    }

    protected boolean submit() throws IOException {
        final var data = createData().toString();
        final var bytes = data.getBytes(UTF_8);

        info("Uncompressed data: " + data);

        try (final var byteOutput = new ByteArrayOutputStream();
             final var output = new GZIPOutputStream(byteOutput)) {

            output.write(bytes);
            output.finish();

            final var compressed = byteOutput.toByteArray();
            info("Compressed size: " + compressed.length + " bytes");

            final var request = HttpRequest.newBuilder()
                    .POST(HttpRequest.BodyPublishers.ofByteArray(compressed))
                    .header("Content-Encoding", "gzip")
                    .header("Content-Type", "application/octet-stream")
                    .header("Authorization", "Bearer " + getToken())
                    .header("User-Agent", "FastStats Metrics")
                    .timeout(Duration.ofSeconds(3))
                    .uri(url)
                    .build();

            info("Sending metrics to: " + url);
            try {
                final var response = httpClient.send(request, HttpResponse.BodyHandlers.ofString(UTF_8));
                final var statusCode = response.statusCode();
                final var body = response.body();

                if (statusCode >= 200 && statusCode < 300) {
                    info("Metrics submitted with status code: " + statusCode + " (" + body + ")");
                    getErrorTracker().map(SimpleErrorTracker.class::cast).ifPresent(SimpleErrorTracker::clear);
                    return true;
                } else if (statusCode >= 300 && statusCode < 400) {
                    warn("Received redirect response from metrics server: " + statusCode + " (" + body + ")");
                } else if (statusCode >= 400 && statusCode < 500) {
                    error("Submitted invalid request to metrics server: " + statusCode + " (" + body + ")", null);
                } else if (statusCode >= 500 && statusCode < 600) {
                    error("Received server error response from metrics server: " + statusCode + " (" + body + ")", null);
                } else {
                    warn("Received unexpected response from metrics server: " + statusCode + " (" + body + ")");
                }
            } catch (final HttpConnectTimeoutException t) {
                error("Metrics submission timed out after 3 seconds: " + url, null);
            } catch (final ConnectException t) {
                error("Failed to connect to metrics server: " + url, null);
            } catch (final Throwable t) {
                error("Failed to submit metrics", t);
            }
            return false;
        }
    }

    private final String javaVersion = System.getProperty("java.version");
    private final String osArch = System.getProperty("os.arch");
    private final String osName = System.getProperty("os.name");
    private final String osVersion = System.getProperty("os.version");
    private final int coreCount = Runtime.getRuntime().availableProcessors();

    protected JsonObject createData() {
        final var data = new JsonObject();
        final var charts = new JsonObject();

        charts.addProperty("java_version", javaVersion);
        charts.addProperty("os_arch", osArch);
        charts.addProperty("os_name", osName);
        charts.addProperty("os_version", osVersion);
        charts.addProperty("core_count", coreCount);

        this.charts.forEach(chart -> {
            try {
                chart.getData().ifPresent(chartData -> charts.add(chart.getId(), chartData));
            } catch (final Throwable t) {
                error("Failed to build chart data: " + chart.getId(), t);
                getErrorTracker().ifPresent(tracker -> tracker.trackError(t));
            }
        });

        try {
            appendDefaultData(charts);
        } catch (final Throwable t) {
            error("Failed to append default data", t);
            getErrorTracker().ifPresent(tracker -> tracker.trackError(t));
        }

        data.addProperty("identifier", config.serverId().toString());
        data.add("data", charts);

        getErrorTracker().map(SimpleErrorTracker.class::cast)
                .map(SimpleErrorTracker::getData)
                .filter(errors -> !errors.isEmpty())
                .ifPresent(errors -> data.add("errors", errors));
        return data;
    }

    @Override
    public @Token String getToken() {
        return token;
    }

    @Override
    public Optional<ErrorTracker> getErrorTracker() {
        return Optional.ofNullable(tracker);
    }

    @Override
    public Metrics.Config getConfig() {
        return config;
    }

    protected boolean isDebug() {
        return debug;
    }

    @Contract(mutates = "param1")
    protected abstract void appendDefaultData(JsonObject charts);

    protected void error(final String message, @Nullable final Throwable throwable) {
        if (isDebug()) printError("[" + getClass().getName() + "]: " + message, throwable);
    }

    protected void warn(final String message) {
        if (isDebug()) printWarning("[" + getClass().getName() + "]: " + message);
    }

    protected void info(final String message) {
        if (isDebug()) printInfo("[" + getClass().getName() + "]: " + message);
    }

    protected abstract void printError(String message, @Nullable Throwable throwable);

    protected abstract void printInfo(String message);

    protected abstract void printWarning(String message);

    @Override
    public void shutdown() {
        getErrorTracker().ifPresent(ErrorTracker::detachErrorContext);
        if (executor != null) try {
            info("Shutting down metrics submission");
            executor.shutdown();
            submit();
        } catch (final Throwable t) {
            error("Failed to submit metrics on shutdown", t);
        } finally {
            executor = null;
        }
    }

    public abstract static class Factory<T, F extends Metrics.Factory<T, F>> implements Metrics.Factory<T, F> {
        private final Set<Chart<?>> charts = new HashSet<>(0);
        private URI url = URI.create("https://metrics.faststats.dev/v1/collect");
        private @Nullable ErrorTracker tracker;
        private @Nullable String token;
        private boolean debug = false;

        @Override
        @SuppressWarnings("unchecked")
        public F addChart(final Chart<?> chart) throws IllegalArgumentException {
            if (!charts.add(chart)) throw new IllegalArgumentException("Chart already added: " + chart.getId());
            return (F) this;
        }

        @Override
        @SuppressWarnings("unchecked")
        public F errorTracker(final ErrorTracker tracker) {
            this.tracker = tracker;
            return (F) this;
        }

        @Override
        @SuppressWarnings("unchecked")
        public F debug(final boolean enabled) {
            this.debug = enabled;
            return (F) this;
        }

        @Override
        @SuppressWarnings("unchecked")
        public F token(@Token final String token) throws IllegalArgumentException {
            if (!token.matches(Token.PATTERN)) {
                throw new IllegalArgumentException("Invalid token '" + token + "', must match '" + Token.PATTERN + "'");
            }
            this.token = token;
            return (F) this;
        }

        @Override
        @SuppressWarnings("unchecked")
        public F url(final URI url) {
            this.url = url;
            return (F) this;
        }
    }

    public record Config(
            UUID serverId,
            boolean additionalMetrics,
            boolean debug,
            boolean enabled,
            boolean errorTracking,
            boolean firstRun,
            boolean externallyManaged
    ) implements Metrics.Config {

        public static final String DEFAULT_COMMENT = """
                 FastStats (https://faststats.dev) collects anonymous usage statistics for plugin developers.
                # This helps developers understand how their projects are used in the real world.
                #
                # No IP addresses, player data, or personal information is collected.
                # The server ID below is randomly generated and can be regenerated at any time.
                #
                # Enabling metrics has no noticeable performance impact.
                # Keeping metrics enabled is recommended, but you can disable them by setting 'enabled=false'.
                #
                # If you suspect a plugin is collecting personal data or bypassing the "enabled" option,
                # please report it at: https://faststats.dev/abuse
                #
                # For more information, visit: https://faststats.dev/info
                """;

        @Contract(mutates = "io")
        public static Config read(final Path file) throws RuntimeException {
            return read(file, DEFAULT_COMMENT, false, false);
        }

        @Contract(mutates = "io")
        public static Config read(final Path file, final String comment, final boolean externallyManaged, final boolean externallyEnabled) throws RuntimeException {
            final var properties = readOrEmpty(file);
            final var firstRun = properties.isEmpty();
            final var saveConfig = new AtomicBoolean(firstRun);

            final var serverId = properties.map(object -> object.getProperty("serverId")).map(string -> {
                try {
                    final var trimmed = string.trim();
                    final var corrected = trimmed.length() > 36 ? trimmed.substring(0, 36) : trimmed;
                    if (!corrected.equals(string)) saveConfig.set(true);
                    return UUID.fromString(corrected);
                } catch (final IllegalArgumentException e) {
                    saveConfig.set(true);
                    return UUID.randomUUID();
                }
            }).orElseGet(() -> {
                saveConfig.set(true);
                return UUID.randomUUID();
            });

            final BiPredicate<String, Boolean> predicate = (key, defaultValue) -> {
                return properties.map(object -> object.getProperty(key)).map(Boolean::parseBoolean).orElseGet(() -> {
                    saveConfig.set(true);
                    return defaultValue;
                });
            };

            final var enabled = externallyManaged ? externallyEnabled : predicate.test("enabled", true);
            final var errorTracking = predicate.test("submitErrors", true);
            final var additionalMetrics = predicate.test("submitAdditionalMetrics", true);
            final var debug = predicate.test("debug", false);

            if (saveConfig.get()) try {
                save(file, externallyManaged, comment, serverId, enabled, errorTracking, additionalMetrics, debug);
            } catch (final IOException e) {
                throw new RuntimeException("Failed to save metrics config", e);
            }

            return new Config(serverId, additionalMetrics, debug, enabled, errorTracking, firstRun, externallyManaged);
        }

        private static Optional<Properties> readOrEmpty(final Path file) throws RuntimeException {
            if (!Files.isRegularFile(file)) return Optional.empty();
            try (final var reader = Files.newBufferedReader(file, UTF_8)) {
                final var properties = new Properties();
                properties.load(reader);
                return Optional.of(properties);
            } catch (final IOException e) {
                throw new RuntimeException("Failed to read metrics config", e);
            }
        }

        private static void save(final Path file, final boolean externallyManaged, final String comment, final UUID serverId, final boolean enabled, final boolean errorTracking, final boolean additionalMetrics, final boolean debug) throws IOException {
            Files.createDirectories(file.getParent());
            try (final var out = Files.newOutputStream(file);
                 final var writer = new OutputStreamWriter(out, UTF_8)) {
                final var properties = new Properties();

                properties.setProperty("serverId", serverId.toString());
                if (!externallyManaged) properties.setProperty("enabled", Boolean.toString(enabled));
                properties.setProperty("submitErrors", Boolean.toString(errorTracking));
                properties.setProperty("submitAdditionalMetrics", Boolean.toString(additionalMetrics));
                properties.setProperty("debug", Boolean.toString(debug));

                properties.store(writer, comment);
            }
        }
    }
}
